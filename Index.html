<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculadora de la Segunda Ley de Fick</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> 

    <style>
        /* Estilos generales */
        body {
            font-family: Arial, sans-serif;
            font-size: 12pt;
            background-color: #f4f7f9;
            color: #333;
            margin: 0;
            padding: 20px;
        }

        .container {
            max-width: 1000px; /* Ancho reducido para un aspecto m√°s compacto */
            margin: 0 auto;
            background-color: #ffffff;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            padding: 0;
        }

        /* Estilos de Pesta√±as (Secciones Paralelas) */
        .tabs {
            display: flex;
            border-bottom: 2px solid #007bff;
        }

        .tab-button {
            padding: 15px 30px;
            cursor: pointer;
            background-color: #f1f1f1;
            border: none;
            outline: none;
            transition: background-color 0.3s, color 0.3s;
            font-weight: bold;
            font-size: 14pt;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            flex-grow: 1;
            text-align: center;
        }

        .tab-button:hover {
            background-color: #e0e0e0;
        }

        .tab-button.active {
            background-color: #007bff;
            color: white;
            border-bottom: 2px solid #007bff;
        }

        .tab-content {
            display: none;
            padding: 25px;
            border-top: none;
        }

        .tab-content.active {
            display: block;
        }
        
        /* Estilos de la Calculadora */
        .calculator-grid {
            display: grid;
            grid-template-columns: 1fr 1fr; /* Dos columnas para los inputs */
            gap: 15px 20px; /* Reducir gap */
            margin-bottom: 20px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            border: 1px solid #e0e0e0; /* Borde m√°s suave */
            padding: 10px;
            border-radius: 4px;
            background-color: #fdfdfd;
        }

        .input-group label {
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 0.9em; /* M√°s peque√±o para claridad */
            color: #555;
        }

        .input-group input, .input-group select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 11pt; /* Tama√±o de fuente ligeramente reducido */
            box-sizing: border-box; /* Incluir padding y border en el ancho/alto */
        }

        .input-inline {
            display: flex;
            gap: 8px; /* Espacio reducido */
            align-items: center;
        }

        .input-inline input {
            flex-grow: 1;
        }

        #unknown-selector, #calculate-btn {
            padding: 10px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14pt;
            transition: background-color 0.3s;
            width: 100%; /* Botones de ancho completo */
            margin-top: 10px;
        }

        #calculate-btn:hover {
            background-color: #218838;
        }

        #results {
            margin-top: 20px;
            padding: 15px;
            background-color: #e9ecef;
            border-radius: 4px;
            font-size: 14pt;
            font-weight: bold;
            border-left: 5px solid #007bff;
            text-align: center; /* Centrar resultados */
        }
        
        /* Estilo espec√≠fico para la ecuaci√≥n de la calculadora (NO LATEX, solo HTML/CSS) */
        #equation-display, .math-equation {
            font-family: 'Arial', sans-serif; 
            font-size: 1.1em;
            background-color: #fff;
            padding: 15px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-top: 10px;
            text-align: center;
            overflow-x: auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .fraction-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 5px;
        }

        .numerator {
            font-size: 1.1em;
        }
        
        .denominator {
            font-size: 1.1em;
        }
        
        .fraction-line {
            border-top: 2px solid #333;
            width: 100%;
            margin: 2px 0;
        }
        
        .erf-argument {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            margin-left: 10px;
            min-width: 80px; /* Ancho m√≠nimo para la fracci√≥n interna */
        }

        /* Estilo para las ecuaciones de la teor√≠a (LATEX) */
        .theory-equation-container {
            font-family: 'Arial', sans-serif;
            font-size: 1.1em;
            padding: 15px 0;
            margin: 10px 0;
            text-align: center;
            /* Usamos display:block para que MathJax pueda renderizar bien las f√≥rmulas */
            display: block; 
            font-weight: bold;
            background-color: #f8f8ff; 
            border-radius: 4px;
            border: 1px dashed #ccc;
        }
        
        /* Estilo para las variables individuales en texto normal (sub√≠ndices, etc.) */
        .variable-name {
            font-style: italic;
            font-weight: bold;
        }


        /* Grafica y su contenedor */
        .graph-section {
            margin-top: 30px; /* Espacio superior para separar de la calculadora */
            padding-top: 20px;
            border-top: 1px solid #eee; /* Separador */
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Contenedor de la gr√°fica para controlar sus dimensiones */
        .chart-container {
            position: relative;
            width: 100%; /* Ocupa el 100% del ancho disponible en su padre */
            max-width: 600px; /* Ancho m√°ximo de la gr√°fica */
            height: 350px; /* Altura fija para la gr√°fica */
            margin: 0 auto; /* Centrar el contenedor de la gr√°fica */
        }

        #fick-chart {
            width: 100% !important; /* Sobreescribir el ancho para ajustarse al contenedor */
            height: 100% !important; /* Sobreescribir la altura para ajustarse al contenedor */
        }

        #graph-interaction {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            width: 100%;
            max-width: 580px; /* Ajustar al ancho de la gr√°fica */
            box-sizing: border-box;
            text-align: center;
        }

        #graph-interaction .input-group {
            border: none;
            background-color: transparent;
            padding: 0;
            margin: 0;
        }
        #graph-interaction .input-inline {
            justify-content: center;
            margin-bottom: 10px;
        }
        #graph-interaction button {
            padding: 8px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12pt;
        }
        #graph-interaction button:hover {
            background-color: #0056b3;
        }
        #check-result {
            margin-top: 10px;
            font-weight: bold;
        }


        /* Estilos de la Teor√≠a */
        .theory-tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid #ccc;
        }
        
        .theory-tab-button {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background-color: #f8f9fa;
            font-weight: bold;
        }
        
        .theory-tab-button.active {
            border-bottom: 3px solid #007bff;
            background-color: #e9ecef;
        }

        .theory-content {
            padding: 15px 0;
        }
        
        .theory-content h3 {
            color: #007bff;
            margin-top: 25px;
            margin-bottom: 15px;
        }

        /* Estilo para im√°genes */
        .theory-content figure {
            margin: 20px 0;
            text-align: center;
        }

        .theory-content img {
            max-width: 80%; /* Hacer las im√°genes un poco m√°s peque√±as */
            height: auto;
            display: block;
            margin: 0 auto; /* Centrar im√°genes */
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        .theory-content figcaption {
            font-style: italic;
            font-size: 0.9em;
            color: #666;
            margin-top: 8px;
        }

        /* Estilo del Mensaje Final */
        .footer-message {
            margin-top: 30px;
            padding: 15px;
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
            border-radius: 4px;
            text-align: center;
            font-style: italic;
            font-size: 0.9em; /* Un poco m√°s peque√±o */
        }
    </style>
</head>
<body>

    <div class="container">
        <div class="tabs">
            <button class="tab-button active" onclick="openTab(event, 'calculator')">Calculadora y Gr√°fica</button>
            <button class="tab-button" onclick="openTab(event, 'theory')">Teor√≠a y Aplicaciones Metal√∫rgicas</button>
            <button class="tab-button" onclick="openTab(event, 'manual')">Manual de Uso</button>
        </div>

        <div id="calculator" class="tab-content active">
            <h2>‚öõÔ∏è Calculadora de la Segunda Ley de Fick (Difusi√≥n No Estacionaria)</h2>
            <p>Ecuaci√≥n utilizada:</p>
            <div id="equation-display">
                <span class="fraction-group">
                    <span class="numerator">(C<sub>s</sub> - C<sub>x</sub>)</span>
                    <span class="fraction-line"></span>
                    <span class="denominator">(C<sub>s</sub> - C<sub>0</sub>)</span>
                </span>
                
                <span style="margin: 0 10px;">= erf [ </span>
                
                <span class="erf-argument">
                    <span class="numerator">X</span>
                    <span class="fraction-line"></span>
                    <span class="denominator">2‚àö(<span style="text-decoration:overline;">D &middot; t</span>)</span>
                </span>
                
                <span style="margin: 0 5px;">]</span>
            </div>
            <label for="unknown-selector">Seleccione la variable inc√≥gnita:</label>
            <select id="unknown-selector" onchange="actualizarInterfaz()">
                <option value="">-- Seleccionar inc√≥gnita --</option>
                <option value="Cx">Concentraci√≥n, C<sub>x</sub> (%√°tomos)</option>
                <option value="Cs">Concentraci√≥n superficial, C<sub>s</sub> (%√°tomos)</option>
                <option value="C0">Concentraci√≥n inicial, C<sub>0</sub> (%√°tomos)</option>
                <option value="X">Distancia, X</option>
                <option value="D">Difusividad, D</option>
                <option value="t">Tiempo, t</option>
            </select>
            
            <hr style="margin: 20px 0; border-top: 1px solid #eee;">

            <div class="calculator-grid" id="input-fields">
                
                <div class="input-group" id="group-Cs">
                    <label for="Cs">Concentraci√≥n superficial, C<sub>s</sub> (%√°tomos):</label>
                    <input type="text" id="Cs" placeholder="Ej: 1.5 o 1,5">
                </div>

                <div class="input-group" id="group-C0">
                    <label for="C0">Concentraci√≥n inicial, C<sub>0</sub> (%√°tomos):</label>
                    <input type="text" id="C0" placeholder="Ej: 0.2 o 0,2">
                </div>

                <div class="input-group" id="group-Cx">
                    <label for="Cx">Concentraci√≥n a X, C<sub>x</sub> (%√°tomos):</label>
                    <input type="text" id="Cx" placeholder="Ej: 0.8 o 0,8">
                </div>

                <div class="input-group" id="group-X">
                    <label for="X">Distancia, X:</label>
                    <div class="input-inline">
                        <input type="text" id="X" placeholder="Ej: 2e-4">
                        <select id="unit-X">
                            <option value="m">metros (m)</option>
                            <option value="cm">cent√≠metros (cm)</option>
                            <option value="mm">mil√≠metros (mm)</option>
                            <option value="pies">pies (ft)</option>
                            <option value="pulgadas">pulgadas (in)</option>
                        </select>
                    </div>
                </div>

                <div class="input-group" id="group-D">
                    <label for="D">Difusividad, D (m¬≤/s):</label>
                    <input type="text" id="D" placeholder="Ej: 3e-11">
                    <small style="margin-top: 5px; text-align: right;">¬øNecesita D? <a href="https://metfistic2025.github.io/Calculadora_METfisTIC_de_difusion/" target="_blank">Calculadora de Difusi√≥n</a></small>
                </div>

                <div class="input-group" id="group-t">
                    <label for="t">Tiempo, t:</label>
                    <div class="input-inline">
                        <input type="text" id="t" placeholder="Ej: 10">
                        <select id="unit-t">
                            <option value="s">segundos (s)</option>
                            <option value="min">minutos (min)</option>
                            <option value="h">horas (h)</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div id="output-unit-selection" style="margin-bottom: 20px; display: none;">
                <label for="output-unit">Unidad para la inc√≥gnita:</label>
                <select id="output-unit"></select>
            </div>

            <button id="calculate-btn" onclick="calcular()">Calcular</button>
            <div id="results"></div>

            <div class="graph-section">
                <h3>Perfil de Concentraci√≥n (C vs X)</h3>
                <div class="chart-container">
                    <canvas id="fick-chart"></canvas>
                </div>
                <div id="graph-interaction">
                    <p>Analizar punto espec√≠fico en el perfil:</p>
                    <div class="input-inline">
                        <div class="input-group">
                            <label for="check-X">Distancia X:</label>
                            <input type="text" id="check-X" placeholder="Distancia">
                        </div>
                        <div class="input-group">
                            <label for="check-C">Concentraci√≥n C<sub>x</sub>:</label>
                            <input type="text" id="check-C" disabled placeholder="%√°tomos">
                        </div>
                    </div>
                    <button onclick="checkPoint()">Ver concentraci√≥n en X</button>
                    <p id="check-result"></p>
                </div>
            </div>
        </div>

        <div id="theory" class="tab-content">
            <h2>üìö Teor√≠a y Aplicaciones de la Segunda Ley de Fick</h2>
            
            <div class="theory-tabs">
                <button class="theory-tab-button active" onclick="openTheoryTab(event, 'teoria')">Teor√≠a Fundamento</button>
                <button class="theory-tab-button" onclick="openTheoryTab(event, 'aplicaciones')">Aplicaciones Metal√∫rgicas</button>
            </div>
            
            <div id="teoria" class="theory-content active">
                <h3>Fundamento de la Segunda Ley de Fick</h3>
                
                <p>La Segunda Ley de Fick es esencial para describir la difusi√≥n no estacionaria (transitoria), donde el flujo difusivo (<span class="variable-name">J</span>) y el gradiente de concentraci√≥n cambian con el tiempo. Esta ley establece que la tasa de cambio de la concentraci√≥n (<span class="variable-name">C</span>) en un punto es directamente proporcional a la curvatura del perfil de concentraci√≥n en ese mismo punto. Matem√°ticamente, se expresa mediante la siguiente ecuaci√≥n diferencial:</p>
                
                <div class="theory-equation-container">
                    $$\frac{\partial C}{\partial t} = D \frac{\partial^2 C}{\partial x^2}$$
                </div>
                <p>En esta ecuaci√≥n, <span class="variable-name">C</span> representa la concentraci√≥n, <span class="variable-name">t</span> el tiempo, <span class="variable-name">x</span> la distancia, y <span class="variable-name">D</span> el coeficiente de difusividad (<span class="variable-name">m</span>¬≤/s). El t√©rmino <span class="variable-name">‚àÇC/‚àÇt</span> indica c√≥mo var√≠a la concentraci√≥n con el tiempo, mientras que <span class="variable-name">‚àÇ¬≤C/‚àÇx¬≤</span> es la segunda derivada que define la curvatura del perfil de concentraci√≥n.</p>
                
                <p>Para casos pr√°cticos, como la difusi√≥n en un s√≥lido semi-infinito con una concentraci√≥n superficial constante (<span class="variable-name">C<sub>s</sub></span>) modelo clave en tratamientos termoqu√≠micos como la cementaci√≥n, la soluci√≥n particular de esta ecuaci√≥n diferencial es la siguiente:</p>

                <div class="theory-equation-container">
                    $$\frac{C_s - C_x}{C_s - C_0} = \text{erf}\left(\frac{x}{2\sqrt{Dt}}\right)$$
                </div>
                <p>Esta soluci√≥n es la base de la calculadora y permite relacionar la concentraci√≥n <span class="variable-name">C<sub>x</sub></span> a una profundidad <span class="variable-name">x</span> y un tiempo <span class="variable-name">t</span>, con respecto a la concentraci√≥n superficial <span class="variable-name">C<sub>s</sub></span> y la concentraci√≥n inicial del material <span class="variable-name">C<sub>0</sub></span>.</p>
                
                <h4>El Perfil de Concentraci√≥n (C vs X)</h4>
                <figure>
                    <img src="https://www.lifeder.com/wp-content/uploads/2020/12/Representacion-2da-ley-de-Fick-618x420.jpg" alt="Gr√°fica de perfil de concentraci√≥n de la Segunda Ley de Fick">
                    <figcaption>Representaci√≥n del perfil de concentraci√≥n para diferentes tiempos de difusi√≥n (<span class="variable-name">t‚ÇÅ</span> &lt; <span class="variable-name">t‚ÇÇ</span> &lt; <span class="variable-name">t‚ÇÉ</span>). </figcaption>
                </figure>
                <p>La gr√°fica del perfil de concentraci√≥n ilustra la distribuci√≥n del elemento difusor (<span class="variable-name">C</span>) en funci√≥n de la distancia (<span class="variable-name">x</span>) desde la superficie. Se observa una curva caracter√≠stica en forma de "S" invertida (o funci√≥n sigmoide), donde la concentraci√≥n es m√°xima en la superficie (<span class="variable-name">C<sub>s</sub></span>) y disminuye de forma no lineal hasta alcanzar la concentraci√≥n inicial del material (<span class="variable-name">C<sub>0</sub></span>) a una profundidad dada. A medida que aumenta el tiempo de difusi√≥n, la curva se desplaza hacia la derecha, indicando que el elemento ha penetrado a mayor profundidad en el material.</p>


                <h4>La Funci√≥n de Error ($\text{erf}(z)$)</h4>
                <p>La funci√≥n de error, denotada como <span class="variable-name">erf(z)</span>, es una integral fundamental que surge de la soluci√≥n de la ecuaci√≥n diferencial de Fick. Es la responsable de la forma curva y no lineal del perfil de concentraci√≥n. Su valor depende del argumento <span class="variable-name">z</span>, que es una variable adimensional que combina la distancia, el tiempo y la difusividad.</p>
                
                <figure>
                    <img src="https://image3.slideserve.com/5858618/valores-de-la-funci-n-de-error-l.jpg" alt="Tabla de valores de la funci√≥n de error (erf(z))">
                    <figcaption>Tabla de valores de la funci√≥n de error (<span class="variable-name">erf(z)</span>) para diferentes valores de <span class="variable-name">z</span>. Esta tabla es esencial para realizar c√°lculos manuales o para la interpolaci√≥n utilizada por esta calculadora, ya que la funci√≥n no tiene una soluci√≥n anal√≠tica directa. </figcaption>
                </figure>
                
                <p>El argumento <span class="variable-name">z</span> en nuestra soluci√≥n de Fick se define como:</p>
                
                <div class="theory-equation-container">
                    $$z = \frac{x}{2\sqrt{Dt}}$$
                </div>
                <p>Debido a que esta integral no posee una soluci√≥n anal√≠tica sencilla, sus valores son obtenidos a partir de tablas precalculadas, como la mostrada. Para el funcionamiento de esta calculadora, se emplea el m√©todo de interpolaci√≥n lineal para encontrar el valor exacto del <span class="variable-name">erf(z)</span> (si se calcula <span class="variable-name">C<sub>x</sub></span>, <span class="variable-name">C<sub>s</sub></span>, o <span class="variable-name">C<sub>0</sub></span>) o para obtener el valor de <span class="variable-name">z</span> (si se calculan <span class="variable-name">x</span>, <span class="variable-name">D</span>, o <span class="variable-name">t</span>).</p>
                
                <h4>Enlace de Ayuda</h4>
                <p>Si desea una explicaci√≥n adicional del tema, este video fue de gran utilidad para entender el concepto:</p>
                <p><a href="https://www.youtube.com/watch?v=6pAbWGyFj-k" target="_blank">Video Explicativo: Segunda Ley de Fick - YouTube</a></p>

            </div>
            
            <div id="aplicaciones" class="theory-content">
                <h3>Utilidades en la Ingenier√≠a Metal√∫rgica</h3>
                <p>La Segunda Ley de Fick es el pilar para el dise√±o y control de los procesos termoqu√≠micos en la metalurgia, cuyo fin es modificar la composici√≥n qu√≠mica superficial de un material para mejorar propiedades cruciales como la dureza, la resistencia al desgaste y la resistencia a la fatiga. El control de la difusi√≥n (a trav√©s de <span class="variable-name">D</span>, <span class="variable-name">t</span> y la temperatura) es vital para lograr la profundidad de la capa deseada.</p>

                <h4>1. Cementaci√≥n (Carburizaci√≥n)</h4>
                <p>Este proceso se utiliza para infundir carbono en la superficie del acero a altas temperaturas, produciendo una capa exterior dura (la capa cementada) sobre un n√∫cleo m√°s blando y tenaz. La ecuaci√≥n de Fick es indispensable para calcular la profundidad de la capa cementada.</p>
                
                <figure>
                    <img src="https://blog.utp.edu.co/metalografia/files/2013/05/Diagrama-Fe-C.jpg" alt="Diagrama de Fases Hierro-Carburo de Hierro (Fe-Fe‚ÇÉC)">
                    <figcaption>Diagrama Hierro-Carburo de Hierro (<span class="variable-name">Fe-Fe‚ÇÉC</span>), clave para definir la temperatura de cementaci√≥n. </figcaption>
                </figure>
                <p>El tratamiento de cementaci√≥n se lleva a cabo dentro de la regi√≥n de austenita gamma, t√≠picamente entre 900¬∞C y 950 ¬∞C, rango que se identifica en el diagrama anteriormente mostrado. Se elige esta temperatura porque la estructura cristalina FCC de la austenita permite que el coeficiente de difusividad (<span class="variable-name">D</span>) del carbono aumente dr√°sticamente, facilitando una r√°pida penetraci√≥n. El acero se expone a un medio carburizante (s√≥lido, l√≠quido o gaseoso) que mantiene la concentraci√≥n superficial (<span class="variable-name">C<sub>s</sub></span>) constante, forzando la difusi√≥n del carbono hacia el interior seg√∫n la ley de Fick.</p>
                
                <figure>
                    <img src="https://sudosilo.com/wp-content/uploads/2020/10/Cementacion2.jpg" alt="Engranes, ejemplos de piezas cementadas.">
                    <figcaption>Engranes, ejemplos de piezas t√≠picamente sometidas a cementaci√≥n para mejorar su resistencia al desgaste superficial. </figcaption>
                </figure>
                <figure>
                    <img src="http://img.youtube.com/vi/VYkNfXXlK1A/0.jpg" alt="Piezas de engranajes post-tratamiento de cementaci√≥n.">
                    <figcaption>Piezas de engranajes despu√©s del tratamiento termoqu√≠mico de cementaci√≥n y posterior temple, con una capa cementada dura. </figcaption>
                </figure>
                <figure>
                    <img src="https://www.researchgate.net/profile/Oscar-Rios-Diez/publication/349636737/figure/download/fig1/AS:995482327334912@1614352890093/Figura-3-Metalografias-acero-AISI-SAE-1020-a-Estado-de-entrega-b-Rampa-de.jpg" alt="Micrograf√≠a de acero cementado mostrando transici√≥n de alto a bajo carbono.">
                    <figcaption>Micrograf√≠a de un acero cementado. La imagen muestra la transici√≥n gradual de una zona de alto carbono (superficie) a la zona de bajo carbono (n√∫cleo), siendo la posici√≥n de esta transici√≥n la que define la profundidad de la capa cementada. </figcaption>
                </figure>

                <h4>2. Nitruraci√≥n y Carbonitruraci√≥n</h4>
                <p>En la Nitruraci√≥n, se difunde nitr√≥geno en la superficie del acero para formar nitruros duros, t√≠picamente a temperaturas inferiores (490 ¬∞C - 550 ¬∞C) a las usadas en cementaci√≥n. En la Carbonitruraci√≥n, se difunden simult√°neamente carbono y nitr√≥geno.</p>
                
                <p>En ambos casos, el control de la profundidad de la capa endurecida se modela y predice a trav√©s de soluciones an√°logas basadas en los principios de la Segunda Ley de Fick, permitiendo predecir el perfil de concentraci√≥n de cada elemento y la cin√©tica de la formaci√≥n de la capa de nitruros.</p>
                
                <figure>
                    <img src="https://tse3.mm.bing.net/th/id/OIP.1UeH4Z7m1W36Oa3gOxVdVQAAAA?pid=Api&P=0&h=180" alt="Micrograf√≠a de una capa nitrurada 1.">
                    <figcaption>Micrograf√≠a de una capa nitrurada mostrando la capa blanca superficial y la zona de difusi√≥n inferior. </figcaption>
                </figure>
                
                <figure>
                    <img src="https://tse2.mm.bing.net/th/id/OIP.T28v88IaWpnnFSq97YnTVwHaFk?pid=Api&P=0&h=180" alt="Micrograf√≠a de una capa nitrurada 2.">
                    <figcaption>Otra micrograf√≠a de una capa nitrurada, resaltando la capa compuesta y la capa de difusi√≥n en el material base. </figcaption>
                </figure>

                <h4>3. Otros Procesos de Aleaci√≥n Superficial</h4>
                <p>La Ley de Fick aplica a cualquier tratamiento que involucre el transporte de masa a trav√©s de un gradiente de concentraci√≥n (por ejemplo, boruraci√≥n, aluminizaci√≥n o siliconizaci√≥n). Estos principios permiten a los ingenieros predecir el espesor de la capa de aleaci√≥n formada y calcular el tiempo de tratamiento requerido para asegurar la calidad y durabilidad del componente.</p>
            </div>
        </div>

        <div id="manual" class="tab-content">
            <h2>üìù Manual de Uso</h2>
            <p>Este programa est√° dise√±ado para calcular las variables de difusi√≥n a partir de la Segunda Ley de Fick para el caso de concentraci√≥n superficial constante. Siga las siguientes instrucciones para un uso √≥ptimo.</p>
            
            <h3>1. Interfaz y Navegaci√≥n</h3>
            <ul>
                <li>La aplicaci√≥n se divide en tres secciones (Calculadora, Teor√≠a y Manual) a las que puede acceder haciendo clic en las pesta√±as superiores.</li>
                <li>Dentro de la secci√≥n de Teor√≠a, encontrar√° pesta√±as para el fundamento te√≥rico y las aplicaciones metal√∫rgicas.</li>
            </ul>

            <h3>2. Uso de la Calculadora</h3>
            <p>El funcionamiento se basa en la ecuaci√≥n de la soluci√≥n de Fick:</p>
            <div class="theory-equation-container">
                 $$\frac{C_s - C_x}{C_s - C_0} = \text{erf}\left(\frac{x}{2\sqrt{Dt}}\right)$$
            </div>

            <h4>Paso a Paso:</h4>
            <ol>
                <li>Seleccionar la Inc√≥gnita: Utilice el selector principal para elegir la variable que desea calcular (<span class="variable-name">C<sub>s</sub></span>, <span class="variable-name">C<sub>0</sub></span>, <span class="variable-name">C<sub>x</sub></span>, <span class="variable-name">x</span>, <span class="variable-name">D</span>, <span class="variable-name">t</span>). Al seleccionarla, su campo de entrada se ocultar√° y aparecer√° la opci√≥n para elegir su unidad de salida (si aplica).</li>
                <li>Ingresar Datos Conocidos: Complete los campos de entrada restantes.</li>
                <li>Formato de Datos:
                    <ul>
                        <li>Decimales: Debe usar la coma (,) como separador decimal (ej: <span class="variable-name">0,5</span> en lugar de <span class="variable-name">0.5</span>).</li>
                        <li>Notaci√≥n Cient√≠fica: Utilice la letra e para la notaci√≥n cient√≠fica (ej: <span class="variable-name">3 &times; 10‚Åª¬π¬π</span> se escribe como <span class="variable-name">3e-11</span>).</li>
                    </ul>
                </li>
                <li>Unidades:
                    <ul>
                        <li>Las concentraciones (<span class="variable-name">C<sub>s</sub></span>, <span class="variable-name">C<sub>0</sub></span>, <span class="variable-name">C<sub>x</sub></span>) siempre se ingresan en %√°tomos.</li>
                        <li>La Difusividad (<span class="variable-name">D</span>) debe ingresarse en m¬≤/s. Si desconoce este valor, se proporciona un enlace a una calculadora auxiliar.</li>
                    </ul>
                </li>
                <li>Unidad de Salida: Si la inc√≥gnita es <span class="variable-name">x</span> o <span class="variable-name">t</span>, seleccione la unidad deseada para el resultado final en la lista desplegable que aparecer√°.</li>
                <li>Calcular: Presione el bot√≥n Calcular para obtener el resultado y generar la gr√°fica de perfil de concentraci√≥n.</li>
            </ol>

            <h3>3. An√°lisis de la Gr√°fica</h3>
            <ul>
                <li>La gr√°fica de Concentraci√≥n (<span class="variable-name">C</span>) vs Distancia (<span class="variable-name">x</span>) se genera autom√°ticamente tras el c√°lculo exitoso.</li>
                <li>Utilice el recuadro inferior para ingresar una Distancia <span class="variable-name">x</span> espec√≠fica y presionar "Ver concentraci√≥n en X" para calcular la <span class="variable-name">C<sub>x</sub></span> en ese punto del perfil.</li>
                <li>Funci√≥n Interactiva: Al mover el rat√≥n sobre la curva, podr√° ver el par de valores (<span class="variable-name">x</span>, <span class="variable-name">C<sub>x</sub></span>) en cualquier punto del perfil.</li>
            </ul>
        </div>

        <div class="footer-message">
            ¬°Esta calculadora forma parte del proyecto MetFisTIC "M√≥dulo TIC de Autoestudio que incorpora Simulaciones e IA para Aprendizaje de Conceptos Fundamentales sobre Metalurgia F√≠sica", dirigido por los profesores Pedro Delvasto y Walter Pardav√©. MetFisTIC fue financiado por la Vicerrector√≠a Acad√©mica de la Universidad Industrial de Santander (2025). La calculadora fue elaborada por Andr√©s Felipe Caro Miranda y revisada por Alisson Vanessa Guerrero Salcedo!.
        </div>

    </div>

    <script>
        // --- CONSTANTES Y TABLA DE ERF ---
        const CONVERSION_X = {
            'm': 1, 'cm': 0.01, 'mm': 0.001, 'pies': 0.3048, 'pulgadas': 0.0254
        };
        const CONVERSION_t = {
            's': 1, 'min': 60, 'h': 3600
        };
        const ERF_TABLE = [
            [0, 0], [0.025, 0.0282], [0.05, 0.0564], [0.10, 0.1125], [0.15, 0.1680],
            [0.20, 0.2227], [0.25, 0.2763], [0.30, 0.3286], [0.35, 0.3794], [0.40, 0.4284],
            [0.45, 0.4755], [0.50, 0.5205], [0.55, 0.5633], [0.60, 0.6039], [0.65, 0.6420],
            [0.70, 0.6778], [0.75, 0.7112], [0.80, 0.7421], [0.85, 0.7707], [0.90, 0.7970],
            [0.95, 0.8209], [1.0, 0.8427], [1.1, 0.8802], [1.2, 0.9103], [1.3, 0.9340],
            [1.4, 0.9523], [1.5, 0.9661], [1.6, 0.9763], [1.7, 0.9838], [1.8, 0.9891],
            [1.9, 0.9928], [2.0, 0.9953], [2.2, 0.9981], [2.4, 0.9993], [2.6, 0.9998],
            [2.8, 0.9999], [3.0, 0.99999] // A√±adido un valor superior para mejor interpolaci√≥n
        ];
        
        // Objeto para manejar la gr√°fica de Chart.js
        let fickChart;

        // --- MANEJO DE ENTRADA Y CONVERSIONES ---
        
        /**
         * Parsea la entrada del usuario, manejando comas y notaci√≥n cient√≠fica.
         * @param {string} value - El valor de entrada.
         * @returns {number | null} - El n√∫mero parseado o null si es inv√°lido.
         */
        function parseInput(value) {
            if (typeof value !== 'string') return null;
            // Reemplazar coma por punto para el parseo JS
            const cleanValue = value.trim().replace(',', '.');
            if (!cleanValue) return null;
            // Manejar notaci√≥n cient√≠fica (ej: 3e-11) y n√∫meros est√°ndar
            const num = Number(cleanValue);
            return isFinite(num) ? num : null;
        }

        /**
         * Convierte el valor de entrada a la unidad interna (metros o segundos).
         */
        function convertirAInterna(valor, unidad, tipo) {
            const conversionMap = tipo === 'X' ? CONVERSION_X : CONVERSION_t;
            return valor * conversionMap[unidad];
        }

        /**
         * Convierte el valor de la unidad interna a la unidad de salida.
         */
        function convertirASalida(valor, unidad, tipo) {
            const conversionMap = tipo === 'X' ? CONVERSION_X : CONVERSION_t;
            // La conversi√≥n es el valor interno dividido por el factor de la unidad de salida
            return valor / conversionMap[unidad];
        }

        /**
         * Formatea un n√∫mero para la salida, usando notaci√≥n cient√≠fica si es muy peque√±o.
         * @param {number} num - N√∫mero a formatear.
         * @param {string} unit - Unidad para mostrar.
         * @returns {string} - Cadena de texto formateada.
         */
        function formatOutput(num, unit = '') {
            // Usar notaci√≥n cient√≠fica para n√∫meros muy grandes o muy peque√±os.
            if (Math.abs(num) > 1e6 || (Math.abs(num) < 1e-4 && Math.abs(num) > 0)) {
                return num.toExponential(4).replace('.', ',');
            }
            // Para otros, usar 5 decimales.
            return num.toFixed(5).replace('.', ',') + ' ' + unit;
        }

        // --- FUNCI√ìN DE ERROR (ERF) E INTERPOLACI√ìN ---

        /**
         * Realiza interpolaci√≥n lineal.
         * @param {number} x - El valor de entrada a interpolar.
         * @param {number} x1 - Punto inferior de la variable de entrada.
         * @param {number} y1 - Punto inferior de la variable de salida.
         * @param {number} x2 - Punto superior de la variable de entrada.
         * @param {number} y2 - Punto superior de la variable de salida.
         * @returns {number} - Valor interpolado.
         */
        function interpolar(x, x1, y1, x2, y2) {
            if (x1 === x2) return y1; // Evitar divisi√≥n por cero
            return y1 + (x - x1) * (y2 - y1) / (x2 - x1);
        }

        /**
         * Calcula erf(z) usando interpolaci√≥n.
         * @param {number} z - El argumento de la funci√≥n de error (X / 2*sqrt(D*t)).
         * @returns {number} - El valor erf(z) interpolado.
         */
        function calcularErf(z) {
            if (z < 0) return -calcularErf(-z); // erf es una funci√≥n impar
            if (z >= ERF_TABLE[ERF_TABLE.length - 1][0]) return 1; // Fuera del rango superior (erf -> 1)
            
            for (let i = 0; i < ERF_TABLE.length - 1; i++) {
                const [z1, erf1] = ERF_TABLE[i];
                const [z2, erf2] = ERF_TABLE[i + 1];

                if (z >= z1 && z <= z2) {
                    return interpolar(z, z1, erf1, z2, erf2);
                }
            }
            return 1; // Caso de fallo, aunque no deber√≠a ocurrir si z >= 0
        }

        /**
         * Calcula z (el inverso de erf) usando interpolaci√≥n.
         * @param {number} E - El valor de la funci√≥n de error (erf(z)).
         * @returns {number} - El argumento z interpolado.
         */
        function calcularZ(E) {
            if (E < 0 || E > 1) {
                // Manejo de valores que no tienen soluci√≥n en la tabla
                return (E > 1) ? 3.0 : -1; // Retornar un valor grande para E>1, o -1 para error
            }
            if (E === 0) return 0;
            if (E === 1) return 3.0; // Valor aproximado (erf(3) es 0.9999779)

            for (let i = 0; i < ERF_TABLE.length - 1; i++) {
                const [z1, erf1] = ERF_TABLE[i];
                const [z2, erf2] = ERF_TABLE[i + 1];

                if (E >= erf1 && E <= erf2) {
                    // Interpolamos para encontrar z a partir de E
                    return interpolar(E, erf1, z1, erf2, z2);
                }
            }
            return 3.0; // En caso de que E sea muy cercano a 1
        }

        // --- L√ìGICA DE LA CALCULADORA ---

        /**
         * Obtiene los valores de entrada y los convierte a unidades internas.
         * @returns {object} - Un objeto con los valores num√©ricos y la inc√≥gnita.
         */
        function obtenerDatos() {
            const unknown = document.getElementById('unknown-selector').value;
            const data = { unknown };
            const ids = ['Cs', 'C0', 'Cx', 'X', 'D', 't'];

            for (const id of ids) {
                if (id !== unknown) {
                    const input = document.getElementById(id);
                    let value = parseInput(input ? input.value : '');

                    if (value === null) {
                        return { error: `Debe ingresar un valor v√°lido para la variable ${id.replace('C', 'C<sub>')} ${id.length > 1 ? '</sub>' : ''}`.replace('C<sub>x</sub>', 'C<sub>x</sub>').replace('C<sub>s</sub>', 'C<sub>s</sub>').replace('C<sub>0</sub>', 'C<sub>0</sub>')};
                    }
                    
                    if (id === 'X') {
                        const unitX = document.getElementById('unit-X').value;
                        data[id] = convertirAInterna(value, unitX, 'X');
                        data['unitX'] = unitX; // Guardar la unidad de entrada de X
                    } else if (id === 't') {
                        const unitT = document.getElementById('unit-t').value;
                        data[id] = convertirAInterna(value, unitT, 't');
                        data['unitT'] = unitT; // Guardar la unidad de entrada de t
                    } else {
                        data[id] = value;
                    }
                }
            }
            
            // Obtener la unidad de salida deseada si aplica
            if (['X', 't'].includes(unknown)) {
                data['outputUnit'] = document.getElementById('output-unit').value;
            }

            return data;
        }

        /**
         * Realiza el c√°lculo basado en la inc√≥gnita seleccionada.
         */
        function calcular() {
            const data = obtenerDatos();
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '';

            if (data.error) {
                resultsDiv.style.backgroundColor = '#f8d7da';
                resultsDiv.style.color = '#721c24';
                resultsDiv.innerHTML = `<strong>Error de entrada:</strong> ${data.error}`;
                generarGraficaVacia(); // Limpiar gr√°fica
                return;
            }

            const { unknown, Cs, C0, Cx, X, D, t } = data;
            let result = null;
            let resultZ = null;
            let resultE = null;
            let unknown_display = unknown.replace('C', 'C<sub>').replace('X', 'X').replace('D', 'D').replace('t', 't');
            if(unknown.length > 1) unknown_display += '</sub>';

            resultsDiv.style.backgroundColor = '#e9ecef';
            resultsDiv.style.color = '#333';

            try {
                if (unknown === 'Cx' || unknown === 'Cs' || unknown === 'C0') {
                    // 1. Calcular z
                    if (D <= 0 || t <= 0) throw new Error("D y t deben ser positivos para el c√°lculo de z.");
                    resultZ = X / (2 * Math.sqrt(D * t));
                    
                    // 2. Calcular erf(z) = E
                    resultE = calcularErf(resultZ);
                    
                    // 3. Despejar la concentraci√≥n inc√≥gnita de E = (Cs - Cx) / (Cs - C0)
                    if (unknown === 'Cs' && Cs === undefined) { // Solo si Cs es la inc√≥gnita
                        if (C0 === undefined || Cx === undefined) throw new Error("Faltan C‚ÇÄ o C‚Çì para calcular C‚Çõ.");
                        if (resultE === 1) throw new Error("Erf(z) es 1, lo que hace la ecuaci√≥n indefinida para C‚Çõ con C‚ÇÄ. Revise los datos.");
                        result = (Cx - resultE * C0) / (1 - resultE);
                    } else if (unknown === 'C0' && C0 === undefined) { // Solo si C0 es la inc√≥gnita
                        if (Cs === undefined || Cx === undefined) throw new Error("Faltan C‚Çõ o C‚Çì para calcular C‚ÇÄ.");
                        if (resultE === 0) throw new Error("Erf(z) es 0, lo que hace la ecuaci√≥n indefinida para C‚ÇÄ con C‚Çõ. Revise los datos.");
                        result = Cs - (Cs - Cx) / resultE;
                    } else if (unknown === 'Cx' && Cx === undefined) { // Solo si Cx es la inc√≥gnita
                        if (Cs === undefined || C0 === undefined) throw new Error("Faltan C‚Çõ o C‚ÇÄ para calcular C‚Çì.");
                        result = Cs - resultE * (Cs - C0);
                    } else {
                        throw new Error("Error en la l√≥gica de c√°lculo de concentraciones.");
                    }
                    
                    if (result === Infinity || result === -Infinity || isNaN(result)) throw new Error("El resultado de concentraci√≥n es indefinido o inv√°lido. Revise los valores de entrada.");
                    
                    resultsDiv.innerHTML = `<strong>Resultado:</strong> ${unknown_display} = ${formatOutput(result)} %√°tomos`;

                } else if (unknown === 'X' || unknown === 'D' || unknown === 't') {
                    // 1. Calcular E = (Cs - Cx) / (Cs - C0)
                    if (Cs === C0) throw new Error("C‚Çõ y C‚ÇÄ son iguales, no hay gradiente de concentraci√≥n. Revise los valores de C‚Çõ y C‚ÇÄ.");
                    resultE = (Cs - Cx) / (Cs - C0);
                    
                    if (resultE < 0 || resultE > 1.0) throw new Error(`El valor E = ${formatOutput(resultE)} est√° fuera del rango de erf (0 a 1), revise las concentraciones: C‚Çõ > C‚Çì > C‚ÇÄ o C‚ÇÄ > C‚Çì > C‚Çõ.`);
                    
                    // 2. Calcular z = erf‚Åª¬π(E)
                    resultZ = calcularZ(resultE);
                    if (resultZ < 0) throw new Error("No se pudo encontrar un valor de z para el E calculado. Revise las concentraciones.");
                    
                    // 3. Despejar la inc√≥gnita de z = X / (2*sqrt(D*t))
                    if (unknown === 'X' && X === undefined) {
                        if (D <= 0 || t <= 0) throw new Error("D y t deben ser positivos para calcular X.");
                        result = resultZ * (2 * Math.sqrt(D * t));
                        const finalUnit = data.outputUnit;
                        result = convertirASalida(result, finalUnit, 'X');
                        resultsDiv.innerHTML = `<strong>Resultado:</strong> ${unknown_display} = ${formatOutput(result, finalUnit)}`;
                    } else if (unknown === 'D' && D === undefined) {
                        if (t <= 0 || resultZ === 0) throw new Error("t debe ser positivo y z no puede ser cero para calcular D.");
                        result = (X * X) / (4 * t * resultZ * resultZ);
                        resultsDiv.innerHTML = `<strong>Resultado:</strong> ${unknown_display} = ${formatOutput(result)} m¬≤/s`;
                    } else if (unknown === 't' && t === undefined) {
                        if (D <= 0 || resultZ === 0) throw new Error("D debe ser positivo y z no puede ser cero para calcular t.");
                        result = (X * X) / (4 * D * resultZ * resultZ);
                        const finalUnit = data.outputUnit;
                        result = convertirASalida(result, finalUnit, 't');
                        resultsDiv.innerHTML = `<strong>Resultado:</strong> ${unknown_display} = ${formatOutput(result, finalUnit)}`;
                    } else {
                        throw new Error("Error en la l√≥gica de c√°lculo de X, D o t.");
                    }
                } else {
                    throw new Error("Por favor, seleccione una inc√≥gnita para calcular.");
                }
                
                // Guardar los √∫ltimos datos calculados para la gr√°fica
                Object.assign(lastCalculatedData, data); // Copia los datos originales
                // Actualizar el valor de la variable calculada en unidades internas
                if (unknown === 'X') {
                    lastCalculatedData[unknown] = convertirAInterna(result, data.outputUnit, unknown);
                } else if (unknown === 't') {
                    lastCalculatedData[unknown] = convertirAInterna(result, data.outputUnit, unknown);
                } else {
                    lastCalculatedData[unknown] = result;
                }
                lastCalculatedData.displayUnitX = (unknown === 'X') ? data.outputUnit : data.unitX;

                // Generar Gr√°fica despu√©s del c√°lculo exitoso
                generarGrafica();

                // Mensaje intermedio limpio
                const intermediateResults = document.createElement('p');
                intermediateResults.innerHTML = `*Valores Intermedios: E = erf(z) = ${formatOutput(resultE)} | z = ${formatOutput(resultZ)}`;
                resultsDiv.appendChild(intermediateResults);

            } catch (e) {
                resultsDiv.style.backgroundColor = '#f8d7da';
                resultsDiv.style.color = '#721c24';
                resultsDiv.innerHTML = `<strong>Error de C√°lculo:</strong> ${e.message}`;
                generarGraficaVacia(); // Limpiar gr√°fica en caso de error
            }
        }
        
        let lastCalculatedData = {}; // Objeto para almacenar los √∫ltimos datos para la gr√°fica

        // --- L√ìGICA DE GR√ÅFICOS ---
        
        /**
         * Calcula Cx a una distancia X, dada la D y t.
         * @param {number} currentX_m - Distancia en metros.
         * @param {object} knownData - Datos C0, Cs, D, t (en unidades internas).
         * @returns {number} - Concentraci√≥n Cx en %√°tomos.
         */
        function calculateCxAtX(currentX_m, knownData) {
            const { Cs, C0, D, t } = knownData;
            // Manejo de casos l√≠mite para evitar NaN o Infinity
            if (D <= 0 || t <= 0) return C0; 
            
            const z = currentX_m / (2 * Math.sqrt(D * t));
            const E = calcularErf(z);
            
            // Cs - Cx = E * (Cs - C0)
            // Cx = Cs - E * (Cs - C0)
            return Cs - E * (Cs - C0);
        }

        /**
         * Genera y muestra la gr√°fica de C vs X.
         */
        function generarGrafica() {
            const { Cs, C0, D, t, X, displayUnitX } = lastCalculatedData;

            if (!Cs || !C0 || !D || !t || !X || Cs === undefined || C0 === undefined || D === undefined || t === undefined || X === undefined) {
                generarGraficaVacia();
                return;
            }

            const conversionFactor = CONVERSION_X[displayUnitX];
            const originalDisplayX = X / conversionFactor; 
            
            // AUMENTO DEL 50% PARA VISUALIZAR EL EQUILIBRIO
            const maxDisplayX = originalDisplayX * 1.5; // Extender el eje X un 50%
            
            // Generar puntos para la curva
            const points = [];
            const numSteps = 100; // N√∫mero de puntos para la suavidad de la curva
            const step = maxDisplayX / numSteps;
            
            const knownData = { Cs, C0, D, t };
            
            for (let i = 0; i <= numSteps; i++) {
                const currentDisplayX = i * step;
                const currentX_m = currentDisplayX * conversionFactor; // Convertir X de vuelta a metros
                const Cx = calculateCxAtX(currentX_m, knownData);
                
                points.push({ x: currentDisplayX, y: Cx });
            }

            const ctx = document.getElementById('fick-chart').getContext('2d');
            
            // Destruir la gr√°fica anterior si existe
            if (fickChart) {
                fickChart.destroy();
            }

            fickChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Perfil de Concentraci√≥n',
                        data: points,
                        parsing: { xAxisKey: 'x', yAxisKey: 'y' },
                        borderColor: '#007bff',
                        borderWidth: 3,
                        pointRadius: 0,
                        fill: false,
                        tension: 0.4 // Suavizar la curva
                    },
                    // L√≠nea de C0 para visualizaci√≥n de equilibrio
                    {
                        label: 'Concentraci√≥n Inicial (C‚ÇÄ)',
                        data: [{x: 0, y: C0}, {x: maxDisplayX, y: C0}],
                        borderColor: '#dc3545',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        pointRadius: 0,
                        fill: false
                    }
                ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false, // Importante para controlar alto y ancho con CSS
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: { display: true, text: `Distancia X (${displayUnitX})` },
                            min: 0,
                            max: maxDisplayX, // Eje X extendido
                        },
                        y: {
                            title: { display: true, text: 'Concentraci√≥n C (%√°tomos)' },
                            min: 0,
                            max: Math.max(Cs, C0) * 1.05, // Asegurar que Cs sea visible, con un margen
                            ticks: {
                                callback: function(value) {
                                    return value.toFixed(2).replace('.', ','); // Formato con coma y 2 decimales
                                }
                            }
                        }
                    }
                }
            });
        }

        /**
         * Genera una gr√°fica vac√≠a o limpia.
         */
        function generarGraficaVacia() {
             if (fickChart) {
                 fickChart.destroy();
             }
             const ctx = document.getElementById('fick-chart').getContext('2d');
             fickChart = new Chart(ctx, {
                 type: 'line',
                 data: { datasets: [] },
                 options: {
                     responsive: true,
                     maintainAspectRatio: false,
                     scales: {
                         x: { type: 'linear', position: 'bottom', title: { display: true, text: 'Distancia X' }, min: 0, max: 1 },
                         y: { title: { display: true, text: 'Concentraci√≥n C (%√°tomos)' }, min: 0, max: 1 }
                     },
                     plugins: {
                         tooltip: { enabled: false }
                     }
                 }
             });
             // Limpiar tambi√©n el cuadro de interacci√≥n
             document.getElementById('check-X').value = '';
             document.getElementById('check-C').value = '';
             document.getElementById('check-result').innerHTML = '';
        }
        
        /**
         * Calcula y muestra Cx para una X dada en el recuadro de an√°lisis.
         */
        function checkPoint() {
            const checkXInput = document.getElementById('check-X');
            const checkCResult = document.getElementById('check-C');
            const checkResultP = document.getElementById('check-result');
            checkCResult.value = '';
            checkResultP.innerHTML = '';

            const { Cs, C0, D, t, displayUnitX } = lastCalculatedData;

            if (!Cs || !C0 || !D || !t || Cs === undefined || C0 === undefined || D === undefined || t === undefined) {
                checkResultP.innerHTML = `<span style="color:red;">Error: Realice un c√°lculo primero para generar la gr√°fica.</span>`;
                return;
            }

            const currentDisplayXValue = parseInput(checkXInput.value);
            if (currentDisplayXValue === null) {
                checkResultP.innerHTML = `<span style="color:red;">Ingrese una Distancia X v√°lida.</span>`;
                return;
            }
            
            // Convertir la X de an√°lisis a metros (usando la unidad de visualizaci√≥n de la gr√°fica)
            const conversionFactor = CONVERSION_X[displayUnitX];
            const currentX_m = currentDisplayXValue * conversionFactor;
            
            const knownData = { Cs, C0, D, t };
            const Cx = calculateCxAtX(currentX_m, knownData);

            checkCResult.value = formatOutput(Cx, '').replace(',', '.'); // Usar punto para el input text
            checkResultP.innerHTML = `<span style="color:green;">Concentraci√≥n a ${formatOutput(currentDisplayXValue, displayUnitX)}: **${formatOutput(Cx, '%√°tomos')}**</span>`;
        }
        
        // --- MANEJO DE INTERFAZ (TABS Y SELECTOR DE INC√ìGNITA) ---
        
        /**
         * Muestra/Oculta la pesta√±a de contenido seleccionada.
         */
        function openTab(evt, tabName) {
            const tabContents = document.getElementsByClassName("tab-content");
            for (let i = 0; i < tabContents.length; i++) {
                tabContents[i].style.display = "none";
            }
            
            const tabButtons = document.getElementsByClassName("tab-button");
            for (let i = 0; i < tabButtons.length; i++) {
                tabButtons[i].className = tabButtons[i].className.replace(" active", "");
            }
            
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";

            // Si se abre la pesta√±a de calculadora, asegurar que la gr√°fica se inicialice
            if (tabName === 'calculator') {
                 generarGraficaVacia(); // O generarGrafica() si se quiere mostrar la √∫ltima calculada
            }
        }
        
        /**
         * Muestra/Oculta la subsecci√≥n de teor√≠a seleccionada.
         */
        function openTheoryTab(evt, tabName) {
            const tabContents = document.querySelectorAll("#theory .theory-content");
            tabContents.forEach(content => content.style.display = "none");
            
            const tabButtons = document.querySelectorAll("#theory .theory-tab-button");
            tabButtons.forEach(button => button.className = button.className.replace(" active", ""));
            
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";
        }

        /**
         * Actualiza la interfaz para ocultar la inc√≥gnita y mostrar el selector de unidad de salida.
         */
        function actualizarInterfaz() {
            const unknown = document.getElementById('unknown-selector').value;
            const groups = ['group-Cs', 'group-C0', 'group-Cx', 'group-X', 'group-D', 'group-t'];
            const outputUnitDiv = document.getElementById('output-unit-selection');
            const outputUnitSelect = document.getElementById('output-unit');
            
            // 1. Mostrar todos los grupos primero
            groups.forEach(id => {
                document.getElementById(id).style.display = 'flex';
            });
            
            // 2. Ocultar el grupo de la inc√≥gnita
            if (unknown) {
                const unknownId = `group-${unknown}`;
                if (document.getElementById(unknownId)) {
                    document.getElementById(unknownId).style.display = 'none';
                }
            }
            
            // 3. Manejar el selector de unidad de salida
            outputUnitDiv.style.display = 'none';
            outputUnitSelect.innerHTML = ''; // Limpiar opciones anteriores
            
            if (unknown === 'X') {
                outputUnitDiv.style.display = 'block';
                const units = CONVERSION_X;
                for (const key in units) {
                    const option = document.createElement('option');
                    option.value = key;
                    // Uso de texto limpio para las opciones de unidad, incluyendo ft/in
                    let text;
                    if (key === 'm') text = 'metros (m)';
                    else if (key === 'cm') text = 'cent√≠metros (cm)';
                    else if (key === 'mm') text = 'mil√≠metros (mm)';
                    else if (key === 'pies') text = 'pies (ft)';
                    else if (key === 'pulgadas') text = 'pulgadas (in)';
                    option.text = text;
                    outputUnitSelect.appendChild(option);
                }
            } else if (unknown === 't') {
                outputUnitDiv.style.display = 'block';
                const units = CONVERSION_t;
                for (const key in units) {
                    const option = document.createElement('option');
                    option.value = key;
                    // Uso de texto limpio para las opciones de unidad
                    option.text = `${key} (${key === 's' ? 'segundos' : key === 'min' ? 'minutos' : key === 'h' ? 'horas' : key})`;
                    outputUnitSelect.appendChild(option);
                }
            }
            // Limpiar resultados y gr√°fica al cambiar la inc√≥gnita
            document.getElementById('results').innerHTML = '';
            generarGraficaVacia();
        }
        
        // Inicializaci√≥n al cargar la p√°gina
        window.onload = () => {
            // Asegura que solo la primera pesta√±a est√© activa al inicio
            document.getElementById('calculator').style.display = 'block';
            document.getElementById('theory').style.display = 'none';
            document.getElementById('manual').style.display = 'none';

            // Asegura que solo la primera subsecci√≥n de teor√≠a est√© activa al inicio
            openTheoryTab({ currentTarget: document.querySelector('#theory .theory-tab-button') }, 'teoria');
            
            // Inicializar la interfaz de la calculadora
            actualizarInterfaz();
            generarGraficaVacia(); // Asegurar que la gr√°fica est√© limpia al inicio
        };

    </script>
</body>
</html>
